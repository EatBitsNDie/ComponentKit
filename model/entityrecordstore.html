<!DOCTYPE html />

<html>
<head>
	<title>EntityRecordStore.cs</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
	<link href="../nocco.css" rel="stylesheet" media="all" type="text/css" />
	<script src="../prettify.js" type="text/javascript"></script>
</head>
<body onload="prettyPrint()">
	<div id="container">
		<div id="background"></div>
			<div id="jump_to">
				Jump To &hellip;
				<div id="jump_wrapper">
					<div id="jump_page">
							<a class="source" href="../componentkit.html">
								ComponentKit.cs
							</a>
							<a class="source" href="../componentsynceventargs.html">
								ComponentSyncEventArgs.cs
							</a>
							<a class="source" href="../entityeventargs.html">
								EntityEventArgs.cs
							</a>
							<a class="source" href="../icomponent.html">
								IComponent.cs
							</a>
							<a class="source" href="../ientityrecord.html">
								IEntityRecord.cs
							</a>
							<a class="source" href="../ientityrecordcollection.html">
								IEntityRecordCollection.cs
							</a>
							<a class="source" href="../isynchronizable.html">
								ISynchronizable.cs
							</a>
							<a class="source" href="../isyncstate.html">
								ISyncState.cs
							</a>
							<a class="source" href="../model/component.html">
								Model\Component.cs
							</a>
							<a class="source" href="../model/componentstateeventargs.html">
								Model\ComponentStateEventArgs.cs
							</a>
							<a class="source" href="../model/dependencycomponent.html">
								Model\DependencyComponent.cs
							</a>
							<a class="source" href="../model/entity.html">
								Model\Entity.cs
							</a>
							<a class="source" href="../model/entityrecord.html">
								Model\EntityRecord.cs
							</a>
							<a class="source" href="../model/entityrecordstore.html">
								Model\EntityRecordStore.cs
							</a>
							<a class="source" href="../model/entityregistry.html">
								Model\EntityRegistry.cs
							</a>
							<a class="source" href="../model/requirecomponentattribute.html">
								Model\RequireComponentAttribute.cs
							</a>
					</div>
				</div>
			</div>
		<table cellpadding="0" cellspacing="0">
			<thead>
				<tr>
					<th class="docs">
						<h1>EntityRecordStore.cs</h1>
					</th>
					<th class="code"></th>
				</tr>
			</thead>
			<tbody>
					<tr id="section_1">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_1">&#182;</a>
							</div>
							<h3>TL;DR..</h3>

<p>Too bad, because this part is missing right now ^_^</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_2">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_2">&#182;</a>
							</div>
							<h2>Source</h2>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>using System;
using System.Collections.Generic;
using System.Linq;

namespace ComponentKit.Model {
</code></pre>
						</td>
					</tr>
					<tr id="section_3">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_3">&#182;</a>
							</div>
							<p>Represents a non-persistent collection of entities that uses triggers to intercept entity changes.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>    internal class EntityRecordStore : IEntityRecordCollection {
        static readonly object _keyhole = new object();

        Dictionary&lt;IEntityRecord, IDictionary&lt;Type, IComponent&gt;&gt; _records =
            new Dictionary&lt;IEntityRecord, IDictionary&lt;Type, IComponent&gt;&gt;();

</code></pre>
						</td>
					</tr>
					<tr id="section_4">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_4">&#182;</a>
							</div>
							<p>Determines whether an entity is registered in the registry.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public bool Contains(IEntityRecord entity) {
            return _records.ContainsKey(entity);
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_5">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_5">&#182;</a>
							</div>
							<p>Registers an entity.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public void Enter(IEntityRecord entity) {
            Add(entity, null);
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_6">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_6">&#182;</a>
							</div>
							<p>Unregisters an entity and returns <code>true</code> if it was successfully dropped.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public bool Drop(IEntityRecord entity) {
            if (entity == null) {
                return false;
            }

            bool entityWasDropped = false;

            IDictionary&lt;Type, IComponent&gt; components = GetComponentsForRecord(entity);

            lock (_keyhole) {
                if (components != null &amp;&amp; components.Count &gt; 0) {
                    foreach (IComponent component in components.Values) {
                        Remove(entity, component);
                    }
                }

                entityWasDropped = _records.Remove(entity);
            }

            if (entityWasDropped) {
                OnRemoved(entity);
            }

            return entityWasDropped;
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_7">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_7">&#182;</a>
							</div>
							<p>Attaches the specified component to an entity.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public void Add(IEntityRecord entity, IComponent component) {
            bool entityWasAlreadyRegistered = true;

            lock (_keyhole) {
                if (component != null) {
                    IEntityRecord previousRecord = component.Record;

                    if (previousRecord != null) {
                        if (!previousRecord.Equals(entity)) {
                            Remove(previousRecord, component);
                        }
                    }
                }

                IDictionary&lt;Type, IComponent&gt; components = GetComponentsForRecord(entity);

                if (components == null) {
                    components = new Dictionary&lt;Type, IComponent&gt;(1);

                    entityWasAlreadyRegistered = false;

                    _records[entity] = components;
                }

                if (component != null) {
                    Type key = component.GetType();

                    if (!components.ContainsKey(key)) {
                        components.Add(key, component);

                        if (component.Record == null || !component.Record.Equals(entity)) {
                            component.Record = entity;
                        }

                        PrepareComponentForSynchronization(component);
                    }
                }
            }

            if (!entityWasAlreadyRegistered) {
                OnEntered(entity);
            }
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_8">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_8">&#182;</a>
							</div>
							<p>Dettaches the specified component from an entity if possible, and returns <code>true</code> if it was successfully removed.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public bool Remove(IEntityRecord entity, IComponent component) {
            if (entity == null ||
                component == null) {
                return false;
            }

</code></pre>
						</td>
					</tr>
					<tr id="section_9">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_9">&#182;</a>
							</div>
							<p>In the unusual case, where the passed component is not actually attached to the passed entity, we need to bail immediately.
Otherwise, if the entity actually had the same type of component attached to it, it would unexpectedly get removed.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>            if (component.Record != null &amp;&amp; !component.Record.Equals(entity)) {
                return false;
            }

            bool componentWasRemoved = false;

            IDictionary&lt;Type, IComponent&gt; components = GetComponentsForRecord(entity);

            lock (_keyhole) {
                if (components != null &amp;&amp; components.Count &gt; 0) {
                    Type key = component.GetType();

                    if (components.ContainsKey(key)) {
                        componentWasRemoved = components.Remove(key);
                    }
                }

                if (component.Record != null) {
                    component.Record = null;
                }

                PrepareComponentForSynchronization(component);
            }

            return componentWasRemoved;
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_10">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_10">&#182;</a>
							</div>
							<p>Occurs when a new entity is registered.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public event EventHandler&lt;EntityEventArgs&gt; Entered;
</code></pre>
						</td>
					</tr>
					<tr id="section_11">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_11">&#182;</a>
							</div>
							<p>Occurs when an entity is unregistered.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public event EventHandler&lt;EntityEventArgs&gt; Removed;

        void OnEntered(IEntityRecord entity) {
            if (Entered != null) {
                Entered(this, new EntityEventArgs(entity));
            }
        }

        void OnRemoved(IEntityRecord entity) {
            if (Removed != null) {
                Removed(this, new EntityEventArgs(entity));
            }
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_12">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_12">&#182;</a>
							</div>
							<p>Returns a component of the specified type if it is attached to the entity.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public T GetComponent&lt;T&gt;(IEntityRecord entity) where T : IComponent {
            T component = default(T);

            return GetComponent(entity, component);
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_13">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_13">&#182;</a>
							</div>
							<p>Returns a component of the specified type if it is attached to the entity.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public T GetComponent&lt;T&gt;(IEntityRecord entity, T component) where T : IComponent {
            if (entity == null) {
                return default(T);
            }

            IDictionary&lt;Type, IComponent&gt; components = GetComponentsForRecord(entity);

            T result = default(T);

            if (components != null &amp;&amp; components.Count &gt; 0) {
                Type componentType = null;

                if (component != null) {
                    componentType = component.GetType();
                } else {
                    componentType = typeof(T);
                }

                if (components.ContainsKey(componentType)) {
                    result = (T)components[componentType];
                }
            }

            return result;
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_14">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_14">&#182;</a>
							</div>
							<p>Returns a component of the specified type if it is attached to the entity.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public IComponent GetComponent(IEntityRecord entity, Type componentType) {
            if (entity == null || componentType == null) {
                return null;
            }

            IDictionary&lt;Type, IComponent&gt; components = GetComponentsForRecord(entity);

            IComponent result = null;

            if (components != null &amp;&amp; components.Count &gt; 0) {
                if (components.ContainsKey(componentType)) {
                    result = components[componentType];
                }
            }

            return result;
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_15">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_15">&#182;</a>
							</div>
							<p>If <code>allowingDerivedTypes</code> is <code>true</code>, returns any component that is either a subclass of, or is, the specified type if it is attached to the entity.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public IComponent GetComponent(IEntityRecord entity, Type componentType, bool allowingDerivedTypes) {
            if (entity == null || componentType == null) {
                return null;
            }

            IDictionary&lt;Type, IComponent&gt; components = GetComponentsForRecord(entity);

            IComponent result = null;

            if (components != null &amp;&amp; components.Count &gt; 0) {
                foreach (IComponent otherComponent in components.Values) {
                    if (otherComponent.GetType().IsEquivalentTo(componentType)) {
                        result = otherComponent;

                        break;
                    }
                }
            }

            return result;
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_16">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_16">&#182;</a>
							</div>
							<p>Returns any component that is either a subclass of, or is, the specified type if it is attached to the entity.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public T GetComponent&lt;T&gt;(IEntityRecord entity, T component, bool allowingDerivedTypes) where T : IComponent {
            IDictionary&lt;Type, IComponent&gt; components = GetComponentsForRecord(entity);

            T result = default(T);

            if (components != null &amp;&amp; components.Count &gt; 0) {
                foreach (IComponent otherComponent in components.Values) {
                    if (otherComponent is T) {
                        result = (T)otherComponent;

                        break;
                    }
                }
            }

            return result;
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_17">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_17">&#182;</a>
							</div>
							<p>Returns all the components that are attached to the entity.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public IEnumerable&lt;IComponent&gt; GetComponents(IEntityRecord entity) {
            IDictionary&lt;Type, IComponent&gt; components = GetComponentsForRecord(entity);

            return components != null ?
                components.Values :
                null;
        }

        IDictionary&lt;Type, IComponent&gt; GetComponentsForRecord(IEntityRecord record) {
            IDictionary&lt;Type, IComponent&gt; components = null;

            lock (_keyhole) {
                if (_records.ContainsKey(record)) {
                    components = _records[record];
                }
            }

            return components;
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_18">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_18">&#182;</a>
							</div>
							<p>Returns all the components that are attached to the specified entity.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public IEnumerable&lt;IComponent&gt; this[IEntityRecord entity] {
            get {
                return GetComponents(entity);
            }
        }

        public IEnumerator&lt;IEntityRecord&gt; GetEnumerator() {
            return _records.Keys.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
            return _records.Keys.GetEnumerator();
        }

        List&lt;IComponent&gt; _desynchronizedComponents =
            new List&lt;IComponent&gt;();

</code></pre>
						</td>
					</tr>
					<tr id="section_19">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_19">&#182;</a>
							</div>
							<p>This registry is considered out-of-sync as soon as there are components that have not yet been run through the triggers.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public bool IsOutOfSync {
            get {
                return _desynchronizedComponents != null &amp;&amp; _desynchronizedComponents.Count &gt; 0;
            }
        }

        void PrepareComponentForSynchronization(IComponent component) {
</code></pre>
						</td>
					</tr>
					<tr id="section_20">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_20">&#182;</a>
							</div>
							<p>It is conceivable that a component might change sync state several times before a synchronization operation occurs, 
so there's no reason to keep growing this list more than necessary.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>            if (!_desynchronizedComponents.Contains(component)) {
                _desynchronizedComponents.Add(component);
            }
        }

        Dictionary&lt;ComponentSyncTriggerPredicate, EventHandler&lt;ComponentSyncEventArgs&gt;&gt; _triggers =
            new Dictionary&lt;ComponentSyncTriggerPredicate, EventHandler&lt;ComponentSyncEventArgs&gt;&gt;();

</code></pre>
						</td>
					</tr>
					<tr id="section_21">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_21">&#182;</a>
							</div>
							<p>Sets a trigger that fires on components matching the specified predicate.</p>

<blockquote>
  <p>Note that triggers are only run during synchronization operations.</p>
</blockquote>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public void SetTrigger(ComponentSyncTriggerPredicate predicate, EventHandler&lt;ComponentSyncEventArgs&gt; handler) {
            lock (_keyhole) {
                _triggers[predicate] = handler;
            }
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_22">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_22">&#182;</a>
							</div>
							<p>Clears out an existing trigger.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public void ClearTrigger(ComponentSyncTriggerPredicate predicate) {
            lock (_keyhole) {
                if (_triggers.ContainsKey(predicate)) {
                    _triggers.Remove(predicate);
                }
            }
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_23">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_23">&#182;</a>
							</div>
							<p>Runs the registered triggers for all components that have changed sync state since the previous synchronization operation.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public void Synchronize() {
            if (_desynchronizedComponents.Count == 0) {
                return;
            }

            lock (_keyhole) {
                foreach (ComponentSyncTriggerPredicate trigger in _triggers.Keys) {
</code></pre>
						</td>
					</tr>
					<tr id="section_24">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_24">&#182;</a>
							</div>
							<p>Discovers all components that matches the predicate described by the <code>trigger</code></p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                    IEnumerable&lt;IComponent&gt; components =
                        _desynchronizedComponents
                            .Where(component =&gt; trigger(component));

                    if (components != null &amp;&amp; components.Count() &gt; 0) {
                        _triggers[trigger](this, new ComponentSyncEventArgs(components));
                    }
                }

                _desynchronizedComponents.Clear();
            }
        }
    }
}

</code></pre>
						</td>
					</tr>
					<tr id="section_25">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_25">&#182;</a>
							</div>
							<p>Copyright 2012 Jacob H. Hansen.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'></code></pre>
						</td>
					</tr>
			</tbody>
		</table>
	</div>
</body>
</html>
