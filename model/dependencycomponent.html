<!DOCTYPE html />

<html>
<head>
	<title>DependencyComponent.cs</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
	<link href="../nocco.css" rel="stylesheet" media="all" type="text/css" />
	<script src="../prettify.js" type="text/javascript"></script>
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-28613716-1']);
    _gaq.push(['_trackPageview']);

    (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
</head>
<body onload="prettyPrint()">
	<div id="container">
		<div id="background"></div>
			<div id="jump_to">
				Jump To &hellip;
				<div id="jump_wrapper">
					<div id="jump_page">
							<a class="source" href="../componentkit.html">
								ComponentKit.cs
							</a>
							<a class="source" href="../componentsynceventargs.html">
								ComponentSyncEventArgs.cs
							</a>
							<a class="source" href="../entityeventargs.html">
								EntityEventArgs.cs
							</a>
							<a class="source" href="../icomponent.html">
								IComponent.cs
							</a>
							<a class="source" href="../ientitydefinitioncollection.html">
								IEntityDefinitionCollection.cs
							</a>
							<a class="source" href="../ientityrecord.html">
								IEntityRecord.cs
							</a>
							<a class="source" href="../ientityrecordcollection.html">
								IEntityRecordCollection.cs
							</a>
							<a class="source" href="../isynchronizable.html">
								ISynchronizable.cs
							</a>
							<a class="source" href="../isyncstate.html">
								ISyncState.cs
							</a>
							<a class="source" href="../model/component.html">
								Model\Component.cs
							</a>
							<a class="source" href="../model/componentstateeventargs.html">
								Model\ComponentStateEventArgs.cs
							</a>
							<a class="source" href="../model/dependencycomponent.html">
								Model\DependencyComponent.cs
							</a>
							<a class="source" href="../model/entity.html">
								Model\Entity.cs
							</a>
							<a class="source" href="../model/entitydefinitions.html">
								Model\EntityDefinitions.cs
							</a>
							<a class="source" href="../model/entityrecord.html">
								Model\EntityRecord.cs
							</a>
							<a class="source" href="../model/entityrecordstore.html">
								Model\EntityRecordStore.cs
							</a>
							<a class="source" href="../model/entityregistry.html">
								Model\EntityRegistry.cs
							</a>
							<a class="source" href="../model/requirecomponentattribute.html">
								Model\RequireComponentAttribute.cs
							</a>
					</div>
				</div>
			</div>
		<table cellpadding="0" cellspacing="0">
			<thead>
				<tr>
					<th class="docs">
						<h1>DependencyComponent.cs</h1>
					</th>
					<th class="code"></th>
				</tr>
			</thead>
			<tbody>
					<tr id="section_1">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_1">&#182;</a>
							</div>
							<h3>TL;DR..</h3>

<p>The <code>DependencyComponent</code> is a <code>Component</code> that is aware of its dependencies, 
and will automatically attempt to inject them during synchronization.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_2">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_2">&#182;</a>
							</div>
							<h2>Source</h2>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>using System;
using System.Collections.Generic;
using System.Reflection;
using System.Globalization;

namespace ComponentKit.Model {
</code></pre>
						</td>
					</tr>
					<tr id="section_3">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_3">&#182;</a>
							</div>
							<p>Represents a component that can specify and inject dependencies.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>    public abstract class DependencyComponent : Component {
        Dictionary&lt;FieldInfo, RequireComponentAttribute&gt; _dependencies =
            new Dictionary&lt;FieldInfo, RequireComponentAttribute&gt;();

        protected DependencyComponent() {
</code></pre>
						</td>
					</tr>
					<tr id="section_4">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_4">&#182;</a>
							</div>
							<p>Since the base constructor is guaranteed to be called (even if 
implemented in a subclass without calling <code>base()</code>), this opportunity 
is used to immediately discover the required dependencies.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>            FindDependencies();
</code></pre>
						</td>
					</tr>
					<tr id="section_5">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_5">&#182;</a>
							</div>
							<blockquote>
  <p>Note that for dependency injection to work, all components must 
  be instantiable and have an empty constructor. However, it is not 
  necessary to implement one.</p>
</blockquote>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        }

</code></pre>
						</td>
					</tr>
					<tr id="section_6">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_6">&#182;</a>
							</div>
							<p>Discovers which member fields are explicitly marked as dependencies.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        void FindDependencies() {
            _dependencies.Clear();

</code></pre>
						</td>
					</tr>
					<tr id="section_7">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_7">&#182;</a>
							</div>
							<blockquote>
  <p>It wouldn't be complete insanity to ditch the attributing entirely 
    and just consider all <code>IComponent</code>-types as dependencies. 
  But, it <em>would</em> ultimately be an assumption, and it could very well 
  lead to some <em>just what exactly is going on behind the scenes?</em>-confusion.</p>
</blockquote>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>            FieldInfo[] fields = GetType().GetFields(
                BindingFlags.Instance |
                BindingFlags.Public |
                BindingFlags.NonPublic);

            foreach (FieldInfo field in fields) {
                foreach (RequireComponentAttribute dependency in 
                            field.GetCustomAttributes(typeof(RequireComponentAttribute), false)) {
                    Type componentType = field.FieldType;

                    if (IsComponent(componentType)) {
                        if (dependency.Automatically) {
                            if (componentType.GetConstructor(Type.EmptyTypes) == null) {
                                throw new InvalidOperationException(
                                    String.Format(CultureInfo.InvariantCulture,
                                        &quot;This field can not be marked as a dependency because its type does not provide a parameter-less constructor.&quot;,
                                        field.DeclaringType.ToString() + &quot;.&quot; + field.Name));
                            }
                        }
                    } else {
                        throw new InvalidOperationException(
                            String.Format(CultureInfo.InvariantCulture,
                                &quot;This field can not be marked as a dependency because its type does not implement &#39;IComponent&#39;.&quot;,
                                field.DeclaringType.ToString() + &quot;.&quot; + field.Name));
                    }

                    try {
                        _dependencies.Add(field, dependency);
                    } catch (ArgumentNullException) {
                        continue;
                    } catch (ArgumentException) {
                        continue;
                    }
                }
            }
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_8">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_8">&#182;</a>
							</div>
							<p>Occurs when the component is attached to an entity. All dependencies are injected.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        protected override void OnAdded(ComponentStateEventArgs registrationArgs) {
            base.OnAdded(registrationArgs);

            InjectDependencies();
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_9">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_9">&#182;</a>
							</div>
							<p>Goes through all discovered dependencies and injects them one by one.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        void InjectDependencies() {
            if (Record == null) {
                return;
            }

            foreach (KeyValuePair&lt;FieldInfo, RequireComponentAttribute&gt; pair in _dependencies) {
                FieldInfo field = pair.Key;
                RequireComponentAttribute dependency = pair.Value;

                if (!dependency.Automatically) {
                    continue;
                }

</code></pre>
						</td>
					</tr>
					<tr id="section_10">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_10">&#182;</a>
							</div>
							<p>Determines which entity the dependency should be grabbed from. </p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                IEntityRecord record =
                    (dependency.FromRecordNamed != null) ?
</code></pre>
						</td>
					</tr>
					<tr id="section_11">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_11">&#182;</a>
							</div>
							<p>The dependency will <strong>not</strong> be injected if the specified entity 
is not registered at the time.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                        Entity.Find(dependency.FromRecordNamed, Record.Registry) :
                        Record;

                if (record == null) {
                    continue;
                }

</code></pre>
						</td>
					</tr>
					<tr id="section_12">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_12">&#182;</a>
							</div>
							<p>Immediately attempt injecting the component.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                InjectDependency(field, record, 
                    allowingDerivedTypes: dependency.AllowDerivedTypes);
            }
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_13">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_13">&#182;</a>
							</div>
							<p>Attempts to inject a component into a field, and adds the component to the specified entity.</p>

<blockquote>
  <p>Note that the dependency will remain, even if it becomes dettached from its entity.</p>
</blockquote>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        void InjectDependency(FieldInfo field, IEntityRecord record, bool allowingDerivedTypes) {
            if (field == null || record == null) {
                return;
            }

            Type componentType = field.FieldType;
            IComponent dependency = record.Registry.GetComponent(record, componentType, allowingDerivedTypes);

            if (dependency == null) {
                dependency = Create(componentType);

                if (dependency == null) {
                    return;
                }

                record.Add(dependency);
            }

            if (dependency != null) {
                field.SetValue(this, dependency);
            }
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_14">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_14">&#182;</a>
							</div>
							<p>Occurs when the component is dettached from an entity. All managed dependencies are null'ed.</p>

<blockquote>
  <p>If you don't want the dependencies to get lost, then override this method and don't base.</p>
</blockquote>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        protected override void OnRemoved(ComponentStateEventArgs registrationArgs) {
            base.OnRemoved(registrationArgs);

            ClearDependencies();
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_15">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_15">&#182;</a>
							</div>
							<p>Clears out all managed dependencies.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        void ClearDependencies() {
            foreach (KeyValuePair&lt;FieldInfo, RequireComponentAttribute&gt; pair in _dependencies) {
                FieldInfo field = pair.Key;

                field.SetValue(this, null);
            }
        }
    }
}

</code></pre>
						</td>
					</tr>
					<tr id="section_16">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_16">&#182;</a>
							</div>
							<p>Copyright 2012 Jacob H. Hansen.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'></code></pre>
						</td>
					</tr>
			</tbody>
		</table>
	</div>
</body>
</html>
